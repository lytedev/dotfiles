<<<<<<< HEAD
#!/usr/bin/env bash

SAVED_PIPELINE_DIR="$DOTFILES_PATH/bin/pipelines"
mkdir -p "$SAVED_PIPELINE_DIR"

if [[ ! -z "${1+x}" ]]; then
	pdir="$SAVED_PIPELINE_DIR/$1"; shift
	mkdir -p "$pdir"
	if [[ -z ${1+x} ]]; then
		td="$(mktemp -p "$pdir" -d "tmp_pipeline.XXXXXXXX")"
		cleanup_trap="rm -rf \"$td\""
	else
		td="$pdir/$1"; shift
		mkdir -p "$td"
	fi
	transform="$pdir/transform"
else
	td="$(mktemp --tmpdir -d pipeline.XXXXXXXX)"
	transform="$td/transform"
	cleanup_trap="rm -rf \"$td\""
fi

if [[ ! -e "$transform" ]]; then
	echo -e "#!/usr/bin/env bash\n# for ${td}\n\nbase64" > "$transform"
fi

in="$td/in"
if [[ ! -z "${1+x}" ]]; then
	in="${1}"; shift
fi
out="$td/out"
if [[ ! -z "${1+x}" ]]; then
	out="${1}"; shift
fi

# TODO: if no logging, log="/dev/null"
log="$td/log"

chmod +x "$transform"
echo "Hello World" > "$in"
touch "$log"

fswi \
	"bash -c 'cd \"$td\" && < \"$in\" \"$transform\" | tee \"$out\"'" \
	'in$|transform$' \
	"$td" "$pdir" &> "$log" &
watcher="$!"

if [[ -z ${cleanup_trap+x} ]]; then
	trap "kill \"$watcher\"" EXIT
else
	trap "${cleanup_trap}; kill \"$watcher\"" EXIT
fi

job="call jobstart(['inotifywait', '-m', '-e', 'close_write', '${out}'], {'on_stdout':{j,d,e->execute('checktime')}})"

# this will only autosave (and therefore autoreload) for the out buffer (since
# it was opened last) - autosaving (and therefore autorunning) is potentially
# very scary
nvim \
	--cmd 'set shm+=atIWF' \
	--cmd 'set shm-=Oo' \
	-o "$in" "$transform" "$out" \
	--cmd 'set autoread' \
	--cmd 'set updatetime=250' \
	--cmd 'autocmd CursorHold,CursorHoldI <buffer> silent write' \
	--cmd "$(<<< "$job" tr "'" '"')"
||||||| bc5ce9e
=======
#!/usr/bin/env bash

SAVED_PIPELINE_DIR="$EDFP/pipelines"
mkdir -p "$SAVED_PIPELINE_DIR"

if [[ ! -z "${1+x}" ]]; then
	pdir="$SAVED_PIPELINE_DIR/$1"; shift
	mkdir -p "$pdir"
	if [[ -z ${1+x} ]]; then
		td="$(mktemp -p "$pdir" -d "tmp_pipeline.XXXXXXXX")"
		cleanup_trap="rm -rf \"$td\""
	else
		td="$pdir/$1"; shift
		mkdir -p "$td"
	fi
	transform="$pdir/transform"
else
	td="$(mktemp --tmpdir -d pipeline.XXXXXXXX)"
	transform="$td/transform"
	cleanup_trap="rm -rf \"$td\""
fi

if [[ ! -e "$transform" ]]; then
	echo -e "#!/usr/bin/env bash\n# for ${td}\n\nbase64" > "$transform"
fi

in="$td/in"
if [[ ! -z "${1+x}" ]]; then
	in="${1}"; shift
fi
out="$td/out"
if [[ ! -z "${1+x}" ]]; then
	out="${1}"; shift
fi

# TODO: if no logging, log="/dev/null"
log="$td/log"

chmod +x "$transform"
echo "Hello World" > "$in"
touch "$log"

fswi \
	"bash -c 'cd \"$td\" && < \"$in\" \"$transform\" | tee \"$out\"'" \
	'in$|transform$' \
	"$td" "$pdir" &> "$log" &
watcher="$!"

if [[ -z ${cleanup_trap+x} ]]; then
	trap "kill \"$watcher\"" EXIT
else
	trap "${cleanup_trap}; kill \"$watcher\"" EXIT
fi

job="call jobstart(['inotifywait', '-m', '-e', 'close_write', '${out}'], {'on_stdout':{j,d,e->execute('checktime')}})"

# this will only autosave (and therefore autoreload) for the out buffer (since
# it was opened last) - autosaving (and therefore autorunning) is potentially
# very scary
nvim \
	--cmd 'set shm+=atIWF' \
	--cmd 'set shm-=Oo' \
	-o "$in" "$transform" "$out" \
	--cmd 'set autoread' \
	--cmd 'set updatetime=250' \
	--cmd 'autocmd CursorHold,CursorHoldI <buffer> silent write' \
	--cmd "$(<<< "$job" tr "'" '"')"
>>>>>>> 0d0e131714c756be933e158919908c19e0c35b2b
